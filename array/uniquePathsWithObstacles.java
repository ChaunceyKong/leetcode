import java.util.*;


//63. 不同路径 II

public class Test {
    // 思路1：路径问题  dfs递归
    // 超时！
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        boolean[][] isVisited = new boolean[obstacleGrid.length][obstacleGrid[0].length];
        dfs(obstacleGrid,0,0, isVisited);
        return path;
    }

    int path = 0; // 维护一个路径总数变量

    public void dfs(int[][] obstacleGrid, int i, int j, boolean[][] isVisited) {
        if (i < 0 || i >= obstacleGrid.length ||
                j < 0 || j >= obstacleGrid[0].length) { //超出边界
            return;
        }
        if (isVisited[i][j]) { //已经走过了
            return;
        }
        if (obstacleGrid[i][j] == 1) { //遇见障碍
            return;
        }
        // 到达右下角终点
        if (i == obstacleGrid.length - 1 && j == obstacleGrid[0].length - 1) {
            path++;
            return;
        }

        isVisited[i][j] = true;
        dfs(obstacleGrid, i + 1, j, isVisited); // 向下移动一格
        dfs(obstacleGrid, i, j + 1, isVisited); // 向右移动一格
        isVisited[i][j] = false;
    }

    //改进：可以使用带备忘录的递归实现动态规划
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        memo = new int[m][n];

        return dp(obstacleGrid, m-1, n-1);
    }

    int[][] memo; //备忘录
    public int dp(int[][] obstacleGrid, int i, int j) {
        // base case
        if (i < 0 || i >= obstacleGrid.length ||
                j < 0 || j >= obstacleGrid[0].length) { //超出边界
            return 0;
        }
        if (obstacleGrid[i][j] == 1) { //遇见障碍
            return 0;
        }
        if (i == 0 && j ==0) {
            return 1;
        }
        if (memo[i][j] > 0) { //剪枝
            return memo[i][j];
        }

        int left = dp(obstacleGrid,i, j-1);
        int up = dp(obstacleGrid, i-1, j);
        int res = left + up;

        memo[i][j] = res;
        return res;
    }

    //思路2：动态规划
    //dp[i][j] 表示到达位置(i,j)的路径条数
    //dp[i][j]=dp[i-1][j] + dp[i][j-1]
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {

        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m+1][n+1];

        //初始化dp
        for (int i = 0; i < m + 1; i++) { //第一列全为0
            dp[i][0] = 0;
        }
        for (int j = 0; j < n + 1; j++) { //第一行全为0
            dp[0][j] = 0;
        }
        dp[1][1] = obstacleGrid[0][0]==1?0:1;

        // 遍历
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == 1 && j == 1) { //base case
                    continue;
                }
                if (obstacleGrid[i-1][j-1] == 1) { //跳过障碍
                    continue;
                }
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }

        return dp[m][n];
    }

    public static void main(String[] args) {
        int[][] obs = {{0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,1,1,0,0,1,0,1,1,0,1,0,0,1,0,0,0,1,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,1,0,0,0},{1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1},{0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0},{0,0,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0},{0,0,0,0,0,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0},{1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,1,0,0,0,1},{0,0,0,0,1,0,0,1,0,1,1,1,0,0,0,1,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0},{0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0},{1,0,1,0,1,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,1,0},{0,0,0,0,0,0,1,0,0,1,1,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,1},{0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,0},{1,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,1,0,0,1,0,0,0,0,0,1,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,1,0,0,0,0,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0},{0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0},{0,0,0,1,0,1,0,0,1,0,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,1,1,1,0,0,0,0,0,0},{0,0,1,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0},{0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0},{1,1,0,0,0,0,1,0,0,1,1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0},{0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,0,1,0,0},{0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0}};

        System.out.println(uniquePathsWithObstacles(obs));

    }

}

